{"version":3,"sources":["webpack:///webpack/bootstrap 50f1dbdd796fe01b0c1a?79b6","webpack:///./src/utils/storage.js?54a2","webpack:///./~/idb-file-storage/src/idb-file-storage.js?0616","webpack:///./src/tab_group_popup.js"],"names":["tabs","storedTabs","name","file","createMutableFile","fh","open","write","JSON","stringify","close","persist","saveTabsToStorage","id","saveFlipperTabId","get","metadata","getMetadata","readAsText","size","parse","loadFlipperTabId","loadTabsFromStorage","persistent","filesStorage","IDBFileStorage","initializedDB","getFileStorage","waitForDOMRequest","req","onsuccess","Promise","resolve","reject","result","onerror","error","IDBPromisedFileHandle","constructor","lockedFile","writeQueue","closed","undefined","aborted","ensureLocked","invalidMode","Error","mode","active","reopenFileHandle","flush","abort","location","readAsArrayBuffer","truncate","append","data","queuedWrite","nextWriteRequest","lastLocation","then","waitForQueuedWrites","IDBPromisedMutableFile","idb","fileName","fileType","mutableFile","fileHandle","getFile","persistAsFileSnapshot","snapshotName","runFileRequestGenerator","objectStore","getObjectStoreTransaction","put","bind","generatorFunction","fileRequestsIter","processFileRequestIter","nextFileRequest","next","prevRequestResult","done","value","window","DOMRequest","IDBRequest","throw","request","indexedDBName","objectStorageName","initializedPromise","version","IDBMutableFile","storage","dbReq","indexedDB","onupgradeneeded","db","objectStoreNames","contains","createObjectStore","transaction","File","Blob","remove","delete","list","options","allKeys","getAllKeys","filteredKeys","filter","match","startsWith","key","endsWith","includes","filterFn","count","length","type","clear","e","reportError","console","elClasses","target","classList","eTmp","clickedTabId","parentElement","slice","removeTabItem","removeFromTabGroup","browser","showTab","log","openNewFlipperTab","query","currentWindow","reset","catch","handleClick","tab","onCreated","tabId","tabIdToRemove","parseInt","i","tabGroup","splice","tabItem","document","createElement","faviconDiv","faviconImg","className","src","favIconUrl","appendChild","textContent","title","tabItemContainer","tabCloseButton","getElementById","onMoved","addEventListener","onError","openingTabId","getTabById","url","creating","create","index","pinned","tabContainer","removeChild","flipperTabId","groupTab","show","update","hide","listenForClicks"],"mappings":"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","file":"tab_group_popup.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 50f1dbdd796fe01b0c1a","import {getFileStorage} from 'idb-file-storage/src/idb-file-storage';\n\nexport async function saveTabsToStorage( tabs ) {\n    const storedTabs = await getFileStorage( { name: \"tabs-grouped\" } );\n    const file = await storedTabs.createMutableFile( \"tabs_grouped.json\" );\n    const fh = file.open( \"readwrite\" );\n    await fh.write( JSON.stringify( tabs ) );\n    await fh.close();\n\n    await file.persist();\n}\n\nexport async function saveFlipperTabId( id ) {\n    const storedTabs = await getFileStorage( { name: \"tabs-grouped\" } );\n    const file = await storedTabs.createMutableFile( \"flipper_tab.json\" );\n    const fh = file.open( \"readwrite\" );\n    await fh.write( JSON.stringify( {id: id} ) );\n    await fh.close();\n\n    await file.persist();\n}\n\nexport async function loadFlipperTabId() {\n    const storedTabs = await getFileStorage( { name: \"tabs-grouped\" } );\n    var file = await storedTabs.get( 'flipper_tab.json' );\n    if( file.open ) {\n        const fh = await file.open( \"readonly\" );\n        const metadata = await fh.getMetadata();\n        var id = await fh.readAsText(metadata.size);\n        id = JSON.parse( id );  \n        await fh.close();\n        return id.id;\n    }\n\n}\n\nexport async function loadTabsFromStorage() {\n    const storedTabs = await getFileStorage( { name: \"tabs-grouped\" } );\n    var file = await storedTabs.get( 'tabs_grouped.json' );\n    if( file.open ) {\n        const fh = await file.open( \"readonly\" );\n        const metadata = await fh.getMetadata();\n        var tabs = await fh.readAsText(metadata.size);\n        tabs = JSON.parse( tabs );  \n        await fh.close();\n        return tabs;\n    }\n\n}\n\n\n// WEBPACK FOOTER //\n// ./src/utils/storage.js","\"use strict\";\n\n/**\n * @typedef {Object} IDBPromisedFileHandle.Metadata\n * @property {number} size\n *   The size of the file in bytes.\n * @property {Date} last Modified\n *   The time and date of the last change to the file.\n */\n\n/**\n * @typedef {Object} IDBFileStorage.ListFilteringOptions\n * @property {string} startsWith\n *   A string to be checked with `fileNameString.startsWith(...)`.\n * @property {string} endsWith\n *   A string to be checked with  `fileNameString.endsWith(...)`.\n * @property {string} includes\n *   A string to be checked with `fileNameString.includes(...)`.\n * @property {function} filterFn\n *   A function to be used to check the file name (`filterFn(fileNameString)`).\n */\n\n/**\n * Wraps a DOMRequest into a promise, optionally transforming the result using the onsuccess\n * callback.\n *\n * @param {IDBRequest|DOMRequest} req\n *   The DOMRequest instance to wrap in a Promise.\n * @param {function}  [onsuccess]\n *   An optional onsuccess callback which can transform the result before resolving it.\n *\n * @returns {Promise}\n *   The promise which wraps the request result, rejected if the request.onerror has been\n *   called.\n */\nexport function waitForDOMRequest(req, onsuccess) {\n  return new Promise((resolve, reject) => {\n    req.onsuccess = onsuccess ?\n      (() => resolve(onsuccess(req.result))) : (() => resolve(req.result));\n    req.onerror = () => reject(req.error);\n  });\n}\n\n/**\n * Wraps an IDBMutableFile's FileHandle with a nicer Promise-based API.\n *\n * Instances of this class are created from the\n * {@link IDBPromisedMutableFile.open} method.\n */\nexport class IDBPromisedFileHandle {\n  /**\n   * @private private helper method used internally.\n   */\n  constructor({file, lockedFile}) {\n    // All the following properties are private and it should not be needed\n    // while using the API.\n\n    /** @private */\n    this.file = file;\n    /** @private */\n    this.lockedFile = lockedFile;\n    /** @private */\n    this.writeQueue = Promise.resolve();\n    /** @private */\n    this.closed = undefined;\n    /** @private */\n    this.aborted = undefined;\n  }\n\n  /**\n   * @private private helper method used internally.\n   */\n  ensureLocked({invalidMode} = {}) {\n    if (this.closed) {\n      throw new Error(\"FileHandle has been closed\");\n    }\n\n    if (this.aborted) {\n      throw new Error(\"FileHandle has been aborted\");\n    }\n\n    if (!this.lockedFile) {\n      throw new Error(\"Invalid FileHandled\");\n    }\n\n    if (invalidMode && this.lockedFile.mode === invalidMode) {\n      throw new Error(`FileHandle should not be opened as '${this.lockedFile.mode}'`);\n    }\n    if (!this.lockedFile.active) {\n      // Automatically relock the file with the last open mode\n      this.file.reopenFileHandle(this);\n    }\n  }\n\n  // Promise-based MutableFile API\n\n  /**\n   * Provide access to the mode that has been used to open the {@link IDBPromisedMutableFile}.\n   *\n   * @type {\"readonly\"|\"readwrite\"|\"writeonly\"}\n   */\n  get mode() {\n    return this.lockedFile.mode;\n  }\n\n  /**\n   * A boolean property that is true if the lock is still active.\n   *\n   * @type {boolean}\n   */\n  get active() {\n    return this.lockedFile ? this.lockedFile.active : false;\n  }\n\n  /**\n   * Close the locked file (and wait for any written data to be flushed if needed).\n   *\n   * @returns {Promise}\n   *   A promise which is resolved when the close request has been completed\n   */\n  async close() {\n    if (!this.lockedFile) {\n      throw new Error(\"FileHandle is not open\");\n    }\n\n    // Wait the queued write to complete.\n    await this.writeQueue;\n\n    // Wait for flush request to complete if needed.\n    if (this.lockedFile.active && this.lockedFile.mode !== \"readonly\") {\n      await waitForDOMRequest(this.lockedFile.flush());\n    }\n\n    this.closed = true;\n    this.lockedFile = null;\n    this.writeQueue = Promise.resolve();\n  }\n\n  /**\n   * Abort any pending data request and set the instance as aborted.\n   *\n   * @returns {Promise}\n   *   A promise which is resolved when the abort request has been completed\n   */\n  async abort() {\n    if (this.lockedFile.active) {\n      // NOTE: in the docs abort is reported to return a DOMRequest, but it doesn't seem\n      // to be the case. (https://developer.mozilla.org/en-US/docs/Web/API/LockedFile/abort)\n      this.lockedFile.abort();\n    }\n\n    this.aborted = true;\n    this.lockedFile = null;\n    this.writeQueue = Promise.resolve();\n  }\n\n  /**\n   * Get the file metadata (take a look to {@link IDBPromisedFileHandle.Metadata} for more info).\n   *\n   * @returns {Promise<{size: number, lastModified: Date}>}\n   *   A promise which is resolved when the request has been completed\n   */\n  async getMetadata() {\n    this.ensureLocked();\n    return waitForDOMRequest(this.lockedFile.getMetadata());\n  }\n\n  /**\n   * Read a given amount of data from the file as Text (optionally starting from the specified\n   * location).\n   *\n   * @param {number} size\n   *   The amount of data to read.\n   * @param {number} [location]\n   *   The location where the request should start to read the data.\n   *\n   * @returns {Promise<string>}\n   *   A promise which resolves to the data read, when the request has been completed.\n   */\n  async readAsText(size, location) {\n    this.ensureLocked({invalidMode: \"writeonly\"});\n    if (typeof location === \"number\") {\n      this.lockedFile.location = location;\n    }\n    return waitForDOMRequest(this.lockedFile.readAsText(size));\n  }\n\n  /**\n   * Read a given amount of data from the file as an ArrayBufer (optionally starting from the specified\n   * location).\n   *\n   * @param {number} size\n   *   The amount of data to read.\n   * @param {number} [location]\n   *   The location where the request should start to read the data.\n   *\n   * @returns {Promise<ArrayBuffer>}\n   *   A promise which resolves to the data read, when the request has been completed.\n   */\n  async readAsArrayBuffer(size, location) {\n    this.ensureLocked({invalidMode: \"writeonly\"});\n    if (typeof location === \"number\") {\n      this.lockedFile.location = location;\n    }\n    return waitForDOMRequest(this.lockedFile.readAsArrayBuffer(size));\n  }\n\n  /**\n   * Truncate the file (optionally at a specified location).\n   *\n   * @param {number} [location=0]\n   *   The location where the file should be truncated.\n   *\n   * @returns {Promise<ArrayBuffer>}\n   *   A promise which is resolved once the request has been completed.\n   */\n  async truncate(location = 0) {\n    this.ensureLocked({invalidMode: \"readonly\"});\n    return waitForDOMRequest(this.lockedFile.truncate(location));\n  }\n\n  /**\n   * Append the passed data to the end of the file.\n   *\n   * @param {string|ArrayBuffer} data\n   *   The data to append to the end of the file.\n   *\n   * @returns {Promise}\n   *   A promise which is resolved once the request has been completed.\n   */\n  async append(data) {\n    this.ensureLocked({invalidMode: \"readonly\"});\n    return waitForDOMRequest(this.lockedFile.append(data));\n  }\n\n  /**\n   * Write data into the file (optionally starting from a defined location in the file).\n   *\n   * @param {string|ArrayBuffer} data\n   *   The data to write into the file.\n   * @param {number} location\n   *   The location where the data should be written.\n   *\n   * @returns {Promise<number>}\n   *   A promise which is resolved to the location where the written data ends.\n   */\n  async write(data, location) {\n    this.ensureLocked({invalidMode: \"readonly\"});\n    if (typeof location === \"number\") {\n      this.lockedFile.location = location;\n    }\n    return waitForDOMRequest(\n      this.lockedFile.write(data),\n      // Resolves to the new location.\n      () => {\n        return this.lockedFile.location;\n      }\n    );\n  }\n\n  /**\n   * Queue data to be written into the file (optionally starting from a defined location in the file).\n   *\n   * @param {string|ArrayBuffer} data\n   *   The data to write into the file.\n   * @param {number} location\n   *   The location where the data should be written (when not specified the end of the previous\n   *   queued write is used).\n   *\n   * @returns {Promise<number>}\n   *   A promise which is resolved once the request has been completed with the location where the\n   *   file was after the data has been writted.\n   */\n  queuedWrite(data, location) {\n    const nextWriteRequest = async lastLocation => {\n      this.ensureLocked({invalidMode: \"readonly\"});\n\n      if (typeof location === \"number\") {\n        return this.write(data, location);\n      }\n      return this.write(data, lastLocation);\n    };\n\n    this.writeQueue = this.writeQueue.then(nextWriteRequest);\n    return this.writeQueue;\n  }\n\n  /**\n   * Wait that any queued data has been written.\n   *\n   * @returns {Promise<number>}\n   *   A promise which is resolved once the request has been completed with the location where the\n   *   file was after the data has been writted.\n   */\n  async waitForQueuedWrites() {\n    await this.writeQueue;\n  }\n}\n\n/**\n * Wraps an IDBMutableFile with a nicer Promise-based API.\n *\n * Instances of this class are created from the\n * {@link IDBFileStorage.createMutableFile} method.\n */\nexport class IDBPromisedMutableFile {\n  /**\n   * @private private helper method used internally.\n   */\n  constructor({filesStorage, idb, fileName, fileType, mutableFile}) {\n    // All the following properties are private and it should not be needed\n    // while using the API.\n\n    /** @private */\n    this.filesStorage = filesStorage;\n    /** @private */\n    this.idb = idb;\n    /** @private */\n    this.fileName = fileName;\n    /** @private */\n    this.fileType = fileType;\n    /** @private */\n    this.mutableFile = mutableFile;\n  }\n\n  /**\n   * @private private helper method used internally.\n   */\n  reopenFileHandle(fileHandle) {\n    fileHandle.lockedFile = this.mutableFile.open(fileHandle.mode);\n  }\n\n  // API methods.\n\n  /**\n   * Open a mutable file for reading/writing data.\n   *\n   * @param {\"readonly\"|\"readwrite\"|\"writeonly\"} mode\n   *   The mode of the created IDBPromisedFileHandle instance.\n   *\n   * @returns {IDBPromisedFileHandle}\n   *   The created IDBPromisedFileHandle instance.\n   */\n  open(mode) {\n    if (this.lockedFile) {\n      throw new Error(\"MutableFile cannot be opened twice\");\n    }\n    const lockedFile = this.mutableFile.open(mode);\n\n    return new IDBPromisedFileHandle({file: this, lockedFile});\n  }\n\n  /**\n   * Get a {@link File} instance of this mutable file.\n   *\n   * @returns {Promise<File>}\n   *   A promise resolved to the File instance.\n   *\n   * To read the actual content of the mutable file as a File object,\n   * it is often better to use {@link IDBPromisedMutableFile.saveAsFileSnapshot}\n   * to save a persistent snapshot of the file in the IndexedDB store,\n   * or reading it directly using the {@link IDBPromisedFileHandle} instance\n   * returned by the {@link IDBPromisedMutableFile.open} method.\n   *\n   * The reason is that to be able to read the content of the returned file\n   * a lockfile have be keep the file open, e.d. as in the following example.\n   *\n   * @example\n   *     ...\n   *     let waitSnapshotStored;\n   *     await mutableFile.runFileRequestGenerator(function* (lockedFile) {\n   *       const file = yield lockedFile.mutableFile.getFile();\n   *       // read the file content or turn it into a persistent object of its own\n   *       // (e.g. by saving it back into IndexedDB as its snapshot in form of a File object,\n   *       // or converted into a data url, a string or an array buffer)\n   *\n   *       waitSnapshotStored = tmpFiles.put(\"${filename}/last_snapshot\", file);\n   *     }\n   *\n   *     await waitSnapshotStored;\n   *     let fileSnapshot = await tmpFiles.get(\"${filename}/last_snapshot\");\n   *     ...\n   *     // now you can use fileSnapshot even if the mutableFile lock is not active anymore.\n   */\n  getFile() {\n    return waitForDOMRequest(this.mutableFile.getFile());\n  }\n\n  /**\n   * Persist the content of the mutable file into the files storage\n   * as a File, using the specified snapshot name and return the persisted File instance.\n   *\n   * @returns {Promise<File>}\n   *   A promise resolved to the File instance.\n   *\n   * @example\n   *\n   *      const file = await mutableFile.persistAsFileSnapshot(`${filename}/last_snapshot`);\n   *      const blobURL = URL.createObjectURL(file);\n   *      ...\n   *      // The blob URL is still valid even if the mutableFile is not active anymore.\n   */\n  async persistAsFileSnapshot(snapshotName) {\n    if (snapshotName === this.fileName) {\n      throw new Error(\"Snapshot name and the file name should be different\");\n    }\n\n    const idb = await this.filesStorage.initializedDB();\n    await this.runFileRequestGenerator(function* () {\n      const file = yield this.mutableFile.getFile();\n      const objectStore = this.filesStorage.getObjectStoreTransaction({idb, mode: \"readwrite\"});\n\n      yield objectStore.put(file, snapshotName);\n    }.bind(this));\n\n    return this.filesStorage.get(snapshotName);\n  }\n\n  /**\n   * Persist the this mutable file into its related IDBFileStorage.\n   *\n   * @returns {Promise}\n   *   A promise resolved on the mutable file has been persisted into IndexedDB.\n   */\n  persist() {\n    return this.filesStorage.put(this.fileName, this);\n  }\n\n  /**\n   * Run a generator function which can run a sequence of FileRequests\n   * without the lockfile to become inactive.\n   *\n   * This method should be rarely needed, mostly to optimize a sequence of\n   * file operations without the file to be closed and automatically re-opened\n   * between two file requests.\n   *\n   * @param {function* (lockedFile) {...}} generatorFunction\n   * @param {\"readonly\"|\"readwrite\"|\"writeonly\"} mode\n   *\n   * @example\n   *   (async function () {\n   *      const tmpFiles = await IDBFiles.getFileStorage({name: \"tmpFiles\"});\n   *      const mutableFile = await tmpFiles.createMutableFile(\"test-mutable-file.txt\");\n   *\n   *      let allFileData;\n   *\n   *      function* fileOperations(lockedFile) {\n   *        yield lockedFile.write(\"some data\");\n   *        yield lockedFile.write(\"more data\");\n   *        const metadata = yield lockedFile.getMetadata();\n   *\n   *        lockedFile.location = 0;\n   *        allFileData = yield lockedFile.readAsText(metadata.size);\n   *      }\n   *\n   *      await mutableFile.runFileRequestGenerator(fileOperations, \"readwrite\");\n   *\n   *      console.log(\"File Data\", allFileData);\n   *   })();\n   */\n  async runFileRequestGenerator(generatorFunction, mode) {\n    if (generatorFunction.constructor.name !== \"GeneratorFunction\") {\n      throw new Error(\"runGenerator parameter should be a generator function\");\n    }\n\n    await new Promise((resolve, reject) => {\n      const lockedFile = this.mutableFile.open(mode || \"readwrite\");\n      const fileRequestsIter = generatorFunction(lockedFile);\n\n      const processFileRequestIter = prevRequestResult => {\n        const nextFileRequest = fileRequestsIter.next(prevRequestResult);\n        if (nextFileRequest.done) {\n          resolve();\n          return;\n        } else if (!(nextFileRequest.value instanceof window.DOMRequest ||\n                     nextFileRequest.value instanceof window.IDBRequest)) {\n          const error = new Error(\"FileRequestGenerator should only yield DOMRequest instances\");\n          fileRequestsIter.throw(error);\n          reject(error);\n          return;\n        }\n\n        const request = nextFileRequest.value;\n        if (request.onsuccess || request.onerror) {\n          const error = new Error(\"DOMRequest onsuccess/onerror callbacks are already set\");\n          fileRequestsIter.throw(error);\n          reject(error);\n        } else {\n          request.onsuccess = () => processFileRequestIter(request.result);\n          request.onerror = () => reject(request.error);\n        }\n      };\n\n      processFileRequestIter();\n    });\n  }\n}\n\n/**\n * Provides a Promise-based API to store files into an IndexedDB.\n *\n * Instances of this class are created using the exported\n * {@link getFileStorage} function.\n */\nexport class IDBFileStorage {\n  /**\n   * @private private helper method used internally.\n   */\n  constructor({name, persistent} = {}) {\n    // All the following properties are private and it should not be needed\n    // while using the API.\n\n    /** @private */\n    this.name = name;\n    /** @private */\n    this.persistent = persistent;\n    /** @private */\n    this.indexedDBName = `IDBFilesStorage-DB-${this.name}`;\n    /** @private */\n    this.objectStorageName = \"IDBFilesObjectStorage\";\n    /** @private */\n    this.initializedPromise = undefined;\n\n    // TODO: evalutate schema migration between library versions?\n    /** @private */\n    this.version = 1.0;\n  }\n\n  /**\n   * @private private helper method used internally.\n   */\n  initializedDB() {\n    if (this.initializedPromise) {\n      return this.initializedPromise;\n    }\n\n    this.initializedPromise = (async () => {\n      if (window.IDBMutableFile && this.persistent) {\n        this.version = {version: this.version, storage: \"persistent\"};\n      }\n      const dbReq = indexedDB.open(this.indexedDBName, this.version);\n\n      dbReq.onupgradeneeded = () => {\n        const db = dbReq.result;\n        if (!db.objectStoreNames.contains(this.objectStorageName)) {\n          db.createObjectStore(this.objectStorageName);\n        }\n      };\n\n      return waitForDOMRequest(dbReq);\n    })();\n\n    return this.initializedPromise;\n  }\n\n  /**\n   * @private private helper method used internally.\n   */\n  getObjectStoreTransaction({idb, mode} = {}) {\n    const transaction = idb.transaction([this.objectStorageName], mode);\n    return transaction.objectStore(this.objectStorageName);\n  }\n\n  /**\n   * Create a new IDBPromisedMutableFile instance (where the IDBMutableFile is supported)\n   *\n   * @param {string} fileName\n   *   The fileName associated to the new IDBPromisedMutableFile instance.\n   * @param {string} [fileType=\"text\"]\n   *   The mime type associated to the file.\n   *\n   * @returns {IDBPromisedMutableFile}\n   *   The newly created {@link IDBPromisedMutableFile} instance.\n   */\n  async createMutableFile(fileName, fileType = \"text\") {\n    if (!window.IDBMutableFile) {\n      throw new Error(\"This environment does not support IDBMutableFile\");\n    }\n    const idb = await this.initializedDB();\n    const mutableFile = await waitForDOMRequest(\n      idb.createMutableFile(fileName, fileType)\n    );\n    return new IDBPromisedMutableFile({\n      filesStorage: this, idb, fileName, fileType, mutableFile\n    });\n  }\n\n  /**\n   * Put a file object into the IDBFileStorage, it overwrites an existent file saved with the\n   * fileName if any.\n   *\n   * @param {string} fileName\n   *   The key associated to the file in the IDBFileStorage.\n   * @param {Blob|File|IDBPromisedMutableFile|IDBMutableFile} file\n   *   The file to be persisted.\n   *\n   * @returns {Promise}\n   *   A promise resolved when the request has been completed.\n   */\n  async put(fileName, file) {\n    if (!fileName || typeof fileName !== \"string\") {\n      throw new Error(\"fileName parameter is mandatory\");\n    }\n\n    if (!(file instanceof File) && !(file instanceof Blob) &&\n        !(window.IDBMutableFile && file instanceof window.IDBMutableFile) &&\n        !(file instanceof IDBPromisedMutableFile)) {\n      throw new Error(`Unable to persist ${fileName}. Unknown file type.`);\n    }\n\n    if (file instanceof IDBPromisedMutableFile) {\n      file = file.mutableFile;\n    }\n\n    const idb = await this.initializedDB();\n    const objectStore = this.getObjectStoreTransaction({idb, mode: \"readwrite\"});\n    return waitForDOMRequest(objectStore.put(file, fileName));\n  }\n\n  /**\n   * Remove a file object from the IDBFileStorage.\n   *\n   * @param {string} fileName\n   *   The fileName (the associated IndexedDB key) to remove from the IDBFileStorage.\n   *\n   * @returns {Promise}\n   *   A promise resolved when the request has been completed.\n   */\n  async remove(fileName) {\n    if (!fileName) {\n      throw new Error(\"fileName parameter is mandatory\");\n    }\n\n    const idb = await this.initializedDB();\n    const objectStore = this.getObjectStoreTransaction({idb, mode: \"readwrite\"});\n    return waitForDOMRequest(objectStore.delete(fileName));\n  }\n\n  /**\n   * List the names of the files stored in the IDBFileStorage.\n   *\n   * (If any filtering options has been specified, only the file names that match\n   * all the filters are included in the result).\n   *\n   * @param {IDBFileStorage.ListFilteringOptions} options\n   *   The optional filters to apply while listing the stored file names.\n   *\n   * @returns {Promise<string[]>}\n   *   A promise resolved to the array of the filenames that has been found.\n   */\n  async list(options) {\n    const idb = await this.initializedDB();\n    const objectStore = this.getObjectStoreTransaction({idb});\n    const allKeys = await waitForDOMRequest(objectStore.getAllKeys());\n\n    let filteredKeys = allKeys;\n\n    if (options) {\n      filteredKeys = filteredKeys.filter(key => {\n        let match = true;\n\n        if (typeof options.startsWith === \"string\") {\n          match = match && key.startsWith(options.startsWith);\n        }\n\n        if (typeof options.endsWith === \"string\") {\n          match = match && key.endsWith(options.endsWith);\n        }\n\n        if (typeof options.includes === \"string\") {\n          match = match && key.includes(options.includes);\n        }\n\n        if (typeof options.filterFn === \"function\") {\n          match = match && options.filterFn(key);\n        }\n\n        return match;\n      });\n    }\n\n    return filteredKeys;\n  }\n\n  /**\n   * Count the number of files stored in the IDBFileStorage.\n   *\n   * (If any filtering options has been specified, only the file names that match\n   * all the filters are included in the final count).\n   *\n   * @param {IDBFileStorage.ListFilteringOptions} options\n   *   The optional filters to apply while listing the stored file names.\n   *\n   * @returns {Promise<number>}\n   *   A promise resolved to the number of files that has been found.\n   */\n  async count(options) {\n    if (!options) {\n      const idb = await this.initializedDB();\n      const objectStore = this.getObjectStoreTransaction({idb});\n      return waitForDOMRequest(objectStore.count());\n    }\n\n    const filteredKeys = await this.list(options);\n    return filteredKeys.length;\n  }\n\n  /**\n   * Retrieve a file stored in the IDBFileStorage by key.\n   *\n   * @param {string} fileName\n   *   The key to use to retrieve the file from the IDBFileStorage.\n   *\n   * @returns {Promise<Blob|File|IDBPromisedMutableFile>}\n   *   A promise resolved once the file stored in the IDBFileStorage has been retrieved.\n   */\n  async get(fileName) {\n    const idb = await this.initializedDB();\n    const objectStore = this.getObjectStoreTransaction({idb});\n    return waitForDOMRequest(objectStore.get(fileName)).then(result => {\n      if (window.IDBMutableFile && result instanceof window.IDBMutableFile) {\n        return new IDBPromisedMutableFile({\n          filesStorage: this,\n          idb,\n          fileName,\n          fileType: result.type,\n          mutableFile: result\n        });\n      }\n\n      return result;\n    });\n  }\n\n  /**\n   * Remove all the file objects stored in the IDBFileStorage.\n   *\n   * @returns {Promise}\n   *   A promise resolved once the IDBFileStorage has been cleared.\n   */\n  async clear() {\n    const idb = await this.initializedDB();\n    const objectStore = this.getObjectStoreTransaction({idb, mode: \"readwrite\"});\n    return waitForDOMRequest(objectStore.clear());\n  }\n}\n\n/**\n * Retrieve an IDBFileStorage instance by name (and it creates the indexedDB if it doesn't\n * exist yet).\n *\n * @param {Object} [param]\n * @param {string} [param.name=\"default\"]\n *   The name associated to the IDB File Storage.\n * @param {boolean} [param.persistent]\n *   Optionally enable persistent storage mode (not enabled by default).\n *\n * @returns {IDBFileStorage}\n *   The IDBFileStorage instance with the given name.\n */\nexport async function getFileStorage({name, persistent} = {}) {\n  const filesStorage = new IDBFileStorage({name: name || \"default\", persistent});\n  await filesStorage.initializedDB();\n  return filesStorage;\n}\n\n/**\n * @external {Blob} https://developer.mozilla.org/en-US/docs/Web/API/Blob\n */\n\n/**\n * @external {DOMRequest} https://developer.mozilla.org/en/docs/Web/API/DOMRequest\n */\n\n/**\n * @external {File} https://developer.mozilla.org/en-US/docs/Web/API/File\n */\n\n/**\n * @external {IDBMutableFile} https://developer.mozilla.org/en-US/docs/Web/API/IDBMutableFile\n */\n\n/**\n * @external {IDBRequest} https://developer.mozilla.org/en-US/docs/Web/API/IDBRequest\n */\n\n\n\n// WEBPACK FOOTER //\n// ./~/idb-file-storage/src/idb-file-storage.js","import { saveTabsToStorage, loadTabsFromStorage, saveFlipperTabId, loadFlipperTabId } from './utils/storage';\n\n/**\n * Listen for clicks on the buttons, and send the appropriate message to\n * the content script in the page.\n */\nasync function listenForClicks() {\n  var tabGroup = await loadTabsFromStorage();\n  for( let tab of tabGroup ) {\n    let tabItem = document.createElement( \"div\" );\n\n    let faviconDiv = document.createElement( \"div\" );\n\n    let faviconImg = document.createElement( \"img\" );\n    faviconImg.className = \"tab_favicon\";\n    faviconImg.src = tab.favIconUrl;\n\n    faviconDiv.appendChild( faviconImg );\n\n    tabItem.id = tab.id;\n    tabItem.className = \"button tab\";\n    tabItem.textContent += tab.title;\n\n    tabItem.appendChild( faviconDiv );\n\n    let tabItemContainer = document.createElement( \"div\" );\n    tabItemContainer.className = \"item_container\";\n\n    tabItemContainer.appendChild( tabItem );\n    tabItemContainer.id = `container-${tab.id}`;\n\n    let tabCloseButton = document.createElement( \"button\" );\n    tabCloseButton.className = \"close\";\n    tabCloseButton.textContent = \"\";\n\n    tabItemContainer.appendChild( tabCloseButton );\n\n    document.getElementById( \"popup-content\" ).appendChild( tabItemContainer );\n  }\n\n  function onMoved( tab ) {\n    console.log( \"Moved \" + tab.id );\n  }\n\n  document.addEventListener( \"click\", handleClick );\n\n  async function handleClick( e ) {\n    function reportError( error ) {\n      console.error( `Error: ${error}` );\n    }\n\n    // Check classes of clicked element to determine\n    // next action:\n\n    let elClasses = e.target.classList;\n    let eTmp = e.target;\n\n    if( elClasses.contains( \"close\" ) \n          ||  elClasses.contains( \"tab\" ) \n          || elClasses.contains( \"open-tab\" )  ){\n      var clickedTabId = eTmp.parentElement.id.slice( 10 )\n    }\n\n    if( elClasses.contains( \"close\" ) ) {\n      removeTabItem( eTmp.parentElement, reportError );\n      await removeFromTabGroup( clickedTabId );\n      await browser.tabs.remove( clickedTabId );\n    } \n    \n    else if( elClasses.contains( \"tab\" ) || elClasses.contains( \"open-tab\" ) ) {\n      try {\n        var id = await loadFlipperTabId();\n        if( id ) {\n          showTab( clickedTabId, id );\n        } \n      } catch( e ) {\n        console.log( e );\n        openNewFlipperTab( clickedTabId ).then(async()=>{\n          id = await loadFlipperTabId();\n          showTab(clickedTabId, id)\n        });\n      }\n    } \n    \n    else if( elClasses.contains( \"reset\" ) ) {\n      browser.tabs\n        .query( { active: true, currentWindow: true } )\n        .then( reset )\n        .catch( reportError );\n    }\n  }\n\n  async function onCreated(tab) {\n    console.log(`Created new tab: ${tab.id}`)\n    await saveFlipperTabId(tab.id);\n\n  }\n  \n  function onError(error) {\n    console.log(`Error: ${error}`);\n  }\n\n  function openNewFlipperTab( openingTabId ) {\n    let tab = getTabById(openingTabId);\n    let url = tab.url;\n    let creating = browser.tabs.create({\n      url,\n      index: 0,\n      active: true,\n      pinned: true\n    });\n    creating.then(onCreated, onError);\n  }\n\n  async function removeFromTabGroup( tabId ) {\n    let tabIdToRemove = parseInt( tabId );\n    console.log( tabIdToRemove );\n    for( let i = tabGroup.length - 1; i >= 0; i-- ) {\n      if( tabGroup[ i ].id == tabIdToRemove ) {\n        console.log( tabGroup );\n        tabGroup.splice( i, 1 );\n        console.log( tabGroup );\n        break;\n      }\n    }\n    await saveTabsToStorage( tabGroup );\n  }\n\n  function removeTabItem( tabContainer, reportError ) {\n    document.getElementById( \"popup-content\" )\n      .removeChild( document.getElementById( tabContainer.id ) );\n  }\n\n  function getTabById( id ) {\n    for( let tab of tabGroup ) {\n      if( tab.id == id ) {\n        return tab;\n      }\n    }\n  }\n\n  function showTab( tabId, flipperTabId ) {\n    if( tabId == flipperTabId ){\n      return;\n    }\n    var groupTab = getTabById( tabId );\n    return new Promise((resolve, reject)=>{\n      browser.tabs.show( parseInt(tabId) ).then(()=>{\n        browser.tabs\n        .update( parseInt(tabId), {\n          active: true,\n          pinned: true,\n        } ).then(()=>{\n          browser.tabs.update( flipperTabId, {\n            pinned: false\n          }).then(()=>{\n            browser.tabs.hide( flipperTabId )\n          }).then(()=>{\n            saveFlipperTabId( parseInt(tabId) ).then(()=>{\n              return Promise.resolve();\n            })\n          })\n        });\n      });\n    })\n\n  }\n}\n\nlistenForClicks();\n\n\n\n// WEBPACK FOOTER //\n// ./src/tab_group_popup.js"],"sourceRoot":""}